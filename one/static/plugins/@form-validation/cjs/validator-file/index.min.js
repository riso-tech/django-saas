/**
 * FormValidation (https://formvalidation.io)
 * The best validation library for JavaScript
 * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>
 *
 * @license https://formvalidation.io/license
 * @package @form-validation/validator-file
 * @version 2.0.2
 */

'use strict';
var e = function (e) {
  return -1 === e.indexOf('.') ? e : e.split('.').slice(0, -1).join('.');
};
exports.file = function () {
  return {
    validate: function (i) {
      if ('' === i.value) return { valid: !0 };
      var t,
        n,
        a = i.options.extension
          ? i.options.extension
              .toLowerCase()
              .split(',')
              .map(function (e) {
                return e.trim();
              })
          : [],
        r = i.options.type
          ? i.options.type
              .toLowerCase()
              .split(',')
              .map(function (e) {
                return e.trim();
              })
          : [];
      if (window.File && window.FileList && window.FileReader) {
        var o = i.element.files,
          s = o.length,
          l = 0;
        if (
          i.options.maxFiles &&
          s > parseInt(''.concat(i.options.maxFiles), 10)
        )
          return { meta: { error: 'INVALID_MAX_FILES' }, valid: !1 };
        if (
          i.options.minFiles &&
          s < parseInt(''.concat(i.options.minFiles), 10)
        )
          return { meta: { error: 'INVALID_MIN_FILES' }, valid: !1 };
        for (var I = {}, p = 0; p < s; p++) {
          if (
            ((l += o[p].size),
            (I = {
              ext: (t = o[p].name.substr(o[p].name.lastIndexOf('.') + 1)),
              file: o[p],
              size: o[p].size,
              type: o[p].type,
            }),
            i.options.minSize &&
              o[p].size < parseInt(''.concat(i.options.minSize), 10))
          )
            return {
              meta: Object.assign({}, { error: 'INVALID_MIN_SIZE' }, I),
              valid: !1,
            };
          if (
            i.options.maxSize &&
            o[p].size > parseInt(''.concat(i.options.maxSize), 10)
          )
            return {
              meta: Object.assign({}, { error: 'INVALID_MAX_SIZE' }, I),
              valid: !1,
            };
          if (-1 === a.indexOf(t.toLowerCase()))
            return {
              meta: Object.assign({}, { error: 'INVALID_EXTENSION' }, I),
              valid: !1,
            };
          if (o[p].type && -1 === r.indexOf(o[p].type.toLowerCase()))
            return {
              meta: Object.assign({}, { error: 'INVALID_TYPE' }, I),
              valid: !1,
            };
          if (
            i.options.validateFileName &&
            !i.options.validateFileName(e(o[p].name))
          )
            return {
              meta: Object.assign({}, { error: 'INVALID_NAME' }, I),
              valid: !1,
            };
        }
        if (
          i.options.maxTotalSize &&
          l > parseInt(''.concat(i.options.maxTotalSize), 10)
        )
          return {
            meta: Object.assign(
              {},
              { error: 'INVALID_MAX_TOTAL_SIZE', totalSize: l },
              I,
            ),
            valid: !1,
          };
        if (
          i.options.minTotalSize &&
          l < parseInt(''.concat(i.options.minTotalSize), 10)
        )
          return {
            meta: Object.assign(
              {},
              { error: 'INVALID_MIN_TOTAL_SIZE', totalSize: l },
              I,
            ),
            valid: !1,
          };
      } else {
        if (
          ((t = i.value.substr(i.value.lastIndexOf('.') + 1)),
          -1 === a.indexOf(t.toLowerCase()))
        )
          return { meta: { error: 'INVALID_EXTENSION', ext: t }, valid: !1 };
        if (
          ((n = e(i.value)),
          i.options.validateFileName && !i.options.validateFileName(n))
        )
          return { meta: { error: 'INVALID_NAME', name: n }, valid: !1 };
      }
      return { valid: !0 };
    },
  };
};
